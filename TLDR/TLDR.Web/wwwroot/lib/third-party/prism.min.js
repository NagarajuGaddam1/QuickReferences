var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function () { var e, t = /\blang(?:uage)?-(\w+)\b/i, n = 0, a = _self.Prism = { util: { encode: function (e) { return e instanceof r ? new r(e.type, a.util.encode(e.content), e.alias) : "Array" === a.util.type(e) ? e.map(a.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (e) { return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1] }, objId: function (e) { return e.__id || Object.defineProperty(e, "__id", { value: ++n }), e.__id }, clone: function (e) { var t, n, r = a.util.type(e); switch (r) { case "Object": t = {}; for (n in e) e.hasOwnProperty(n) && (t[n] = a.util.clone(e[n])); return t; case "Array": return e.map && e.map(function (e) { return a.util.clone(e) }) } return e } }, languages: { extend: function (e, t) { var n, r = a.util.clone(a.languages[e]); for (n in t) r[n] = t[n]; return r }, insertBefore: function (e, t, n, r) { var i, s, l, o; if (r = r || a.languages, i = r[e], 2 == arguments.length) { n = arguments[1]; for (s in n) n.hasOwnProperty(s) && (i[s] = n[s]); return i } l = {}; for (o in i) if (i.hasOwnProperty(o)) { if (o == t) for (s in n) n.hasOwnProperty(s) && (l[s] = n[s]); l[o] = i[o] } return a.languages.DFS(a.languages, function (t, n) { n === r[e] && t != e && (this[t] = l) }), r[e] = l }, DFS: function (e, t, n, r) { r = r || {}; for (var i in e) e.hasOwnProperty(i) && (t.call(e, i, e[i], n || i), "Object" !== a.util.type(e[i]) || r[a.util.objId(e[i])] ? "Array" !== a.util.type(e[i]) || r[a.util.objId(e[i])] || (r[a.util.objId(e[i])] = !0, a.languages.DFS(e[i], t, i, r)) : (r[a.util.objId(e[i])] = !0, a.languages.DFS(e[i], t, null, r))) } }, plugins: {}, highlightAll: function (e, t) { var n, r, i, s = { callback: t, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; for (a.hooks.run("before-highlightall", s), n = s.elements || document.querySelectorAll(s.selector), r = 0; i = n[r++];) a.highlightElement(i, e === !0, s.callback) }, highlightElement: function (e, n, r) { for (var i, s, l, o, u, g = e; g && !t.test(g.className) ;) g = g.parentNode; return g && (i = (g.className.match(t) || [, ""])[1].toLowerCase(), s = a.languages[i]), e.className = e.className.replace(t, "").replace(/\s+/g, " ") + " language-" + i, g = e.parentNode, /pre/i.test(g.nodeName) && (g.className = g.className.replace(t, "").replace(/\s+/g, " ") + " language-" + i), l = e.textContent, o = { element: e, language: i, grammar: s, code: l }, a.hooks.run("before-sanity-check", o), o.code && o.grammar ? (a.hooks.run("before-highlight", o), void (n && _self.Worker ? (u = new Worker(a.filename), u.onmessage = function (e) { o.highlightedCode = e.data, a.hooks.run("before-insert", o), o.element.innerHTML = o.highlightedCode, r && r.call(o.element), a.hooks.run("after-highlight", o), a.hooks.run("complete", o) }, u.postMessage(JSON.stringify({ language: o.language, code: o.code, immediateClose: !0 }))) : (o.highlightedCode = a.highlight(o.code, o.grammar, o.language), a.hooks.run("before-insert", o), o.element.innerHTML = o.highlightedCode, r && r.call(e), a.hooks.run("after-highlight", o), a.hooks.run("complete", o)))) : (o.code && (o.element.textContent = o.code), void a.hooks.run("complete", o)) }, highlight: function (e, t, n) { var i = a.tokenize(e, t); return r.stringify(a.util.encode(i), n) }, tokenize: function (e, t, n) { var r, i, s, l, o, u, g, c, p, d, m, h, f, y, b, w, k, P, v, x, A, j, _, C, E = a.Token, N = [e], W = t.rest; if (W) { for (r in W) t[r] = W[r]; delete t.rest }e: for (r in t) if (t.hasOwnProperty(r) && t[r]) for (i = t[r], i = "Array" === a.util.type(i) ? i : [i], s = 0; s < i.length; ++s) for (l = i[s], o = l.inside, u = !!l.lookbehind, g = !!l.greedy, c = 0, p = l.alias, g && !l.pattern.global && (d = ("" + l.pattern).match(/[imuy]*$/)[0], l.pattern = RegExp(l.pattern.source, d + "g")), l = l.pattern || l, m = 0, h = 0; m < N.length; h += N[m].length, ++m) { if (f = N[m], N.length > e.length) break e; if (!(f instanceof E)) { if (l.lastIndex = 0, y = l.exec(f), b = 1, !y && g && m != N.length - 1) { if (l.lastIndex = h, y = l.exec(e), !y) break; for (w = y.index + (u ? y[1].length : 0), k = y.index + y[0].length, P = m, v = h, x = N.length; x > P && k > v; ++P) v += N[P].length, w >= v && (++m, h = v); if (N[m] instanceof E || N[P - 1].greedy) continue; b = P - m, f = e.slice(h, v), y.index -= h } y && (u && (c = y[1].length), w = y.index + c, y = y[0].slice(c), k = w + y.length, A = f.slice(0, w), j = f.slice(k), _ = [m, b], A && _.push(A), C = new E(r, o ? a.tokenize(y, o) : y, p, y, g), _.push(C), j && _.push(j), Array.prototype.splice.apply(N, _)) } } return N }, hooks: { all: {}, add: function (e, t) { var n = a.hooks.all; n[e] = n[e] || [], n[e].push(t) }, run: function (e, t) { var n, r, i = a.hooks.all[e]; if (i && i.length) for (n = 0; r = i[n++];) r(t) } } }, r = a.Token = function (e, t, n, a, r) { this.type = e, this.content = t, this.alias = n, this.length = 0 | (a || "").length, this.greedy = !!r }; return r.stringify = function (e, t, n) { var i, s, l; return "string" == typeof e ? e : "Array" === a.util.type(e) ? e.map(function (n) { return r.stringify(n, t, e) }).join("") : (i = { type: e.type, content: r.stringify(e.content, t, n), tag: "span", classes: ["token", e.type], attributes: {}, language: t, parent: n }, "comment" == i.type && (i.attributes.spellcheck = "true"), e.alias && (s = "Array" === a.util.type(e.alias) ? e.alias : [e.alias], Array.prototype.push.apply(i.classes, s)), a.hooks.run("wrap", i), l = Object.keys(i.attributes).map(function (e) { return e + '="' + (i.attributes[e] || "").replace(/"/g, "&quot;") + '"' }).join(" "), "<" + i.tag + ' class="' + i.classes.join(" ") + '"' + (l ? " " + l : "") + ">" + i.content + "</" + i.tag + ">") }, _self.document ? (e = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop(), e && (a.filename = e.src, document.addEventListener && !e.hasAttribute("data-manual") && ("loading" !== document.readyState ? window.requestAnimationFrame ? window.requestAnimationFrame(a.highlightAll) : window.setTimeout(a.highlightAll, 16) : document.addEventListener("DOMContentLoaded", a.highlightAll))), _self.Prism) : _self.addEventListener ? (_self.addEventListener("message", function (e) { var t = JSON.parse(e.data), n = t.language, r = t.code, i = t.immediateClose; _self.postMessage(a.highlight(r, a.languages[n], n)), i && _self.close() }, !1), _self.Prism) : _self.Prism }(); "undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism), Prism.languages.markup = { comment: /<!--[\w\W]*?-->/, prolog: /<\?[\w\W]+?\?>/, doctype: /<!DOCTYPE[\w\W]+?>/i, cdata: /<!\[CDATA\[[\w\W]*?]]>/i, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i, inside: { tag: { pattern: /^<\/?[^\s>\/]+/i, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "attr-value": { pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i, inside: { punctuation: /[=>"']/ } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: /&#?[\da-z]{1,8};/i }, Prism.hooks.add("wrap", function (e) { "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&")) }), Prism.languages.xml = Prism.languages.markup, Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.css = { comment: /\/\*[\w\W]*?\*\//, atrule: { pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i, inside: { rule: /@[\w-]+/ } }, url: /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i, selector: /[^\{\}\s][^\{\};]*?(?=\s*\{)/, string: { pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, property: /(\b|\B)[\w-]+(?=\s*:)/i, important: /\B!important\b/i, "function": /[-a-z0-9]+(?=\()/i, punctuation: /[(){};:]/ }, Prism.languages.css.atrule.inside.rest = Prism.util.clone(Prism.languages.css), Prism.languages.markup && (Prism.languages.insertBefore("markup", "tag", { style: { pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i, lookbehind: !0, inside: Prism.languages.css, alias: "language-css" } }), Prism.languages.insertBefore("inside", "attr-value", { "style-attr": { pattern: /\s*style=("|').*?\1/i, inside: { "attr-name": { pattern: /^\s*style/i, inside: Prism.languages.markup.tag.inside }, punctuation: /^\s*=\s*['"]|['"]\s*$/, "attr-value": { pattern: /.+/i, inside: Prism.languages.css } }, alias: "language-css" } }, Prism.languages.markup.tag)), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\w\W]*?\*\//, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0 }], string: { pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i, lookbehind: !0, inside: { punctuation: /(\.|\\)/ } }, keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, "boolean": /\b(true|false)\b/, "function": /[a-z0-9_]+(?=\()/i, number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { keyword: /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/, number: /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/, "function": /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/ }), Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: /(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/, lookbehind: !0, greedy: !0 } }), Prism.languages.insertBefore("javascript", "string", { "template-string": { pattern: /`(?:\\\\|\\?[^\\])*?`/, greedy: !0, inside: { interpolation: { pattern: /\$\{[^}]+\}/, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } } }), Prism.languages.markup && Prism.languages.insertBefore("markup", "tag", { script: { pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i, lookbehind: !0, inside: Prism.languages.javascript, alias: "language-javascript" } }), Prism.languages.js = Prism.languages.javascript, function () { "undefined" != typeof self && self.Prism && self.document && document.querySelector && (self.Prism.fileHighlight = function () { var e = { js: "javascript", py: "python", rb: "ruby", ps1: "powershell", psm1: "powershell", sh: "bash", bat: "batch", h: "c", tex: "latex" }; Array.prototype.forEach && Array.prototype.slice.call(document.querySelectorAll("pre[data-src]")).forEach(function (t) { for (var n, a, r, i, s = t.getAttribute("data-src"), l = t, o = /\blang(?:uage)?-(?!\*)(\w+)\b/i; l && !o.test(l.className) ;) l = l.parentNode; l && (n = (t.className.match(o) || [, ""])[1]), n || (a = (s.match(/\.(\w+)$/) || [, ""])[1], n = e[a] || a), r = document.createElement("code"), r.className = "language-" + n, t.textContent = "", r.textContent = "Loading…", t.appendChild(r), i = new XMLHttpRequest, i.open("GET", s, !0), i.onreadystatechange = function () { 4 == i.readyState && (i.status < 400 && i.responseText ? (r.textContent = i.responseText, Prism.highlightElement(r)) : i.status >= 400 ? r.textContent = "✖ Error " + i.status + " while fetching file: " + i.statusText : r.textContent = "✖ Error: File does not exist or is empty") }, i.send(null) }) }, document.addEventListener("DOMContentLoaded", self.Prism.fileHighlight)) }();